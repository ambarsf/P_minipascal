package p_minipascal;
import necessities.*;
import java.util.*;
import java.io.*;
parser code {:
    
    /* Change the method report_error so it will display the line and
       column of where the error occurred in the input as well as the
       reason for the error which is passed into the method in the
       String 'message'. */
    public void report_error(String message, Object info) {
   
        /* Create a StringBuilder called 'm' with the string 'Error' in it. */
        StringBuilder m = new StringBuilder("Error");
   
        /* Check if the information passed to the method is the same
           type as the type java_cup.runtime.Symbol. */
        if (info instanceof java_cup.runtime.Symbol) {
            /* Declare a java_cup.runtime.Symbol object 's' with the
               information in the object info that is being typecasted
               as a java_cup.runtime.Symbol object. */
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
   
            /* Check if the line number in the input is greater or
               equal to zero. */
            if (s.left >= 0) {                
                /* Add to the end of the StringBuilder error message
                   the line number of the error in the input. */
                m.append(" in line "+(s.left+1));   
                /* Check if the column number in the input is greater
                   or equal to zero. */
                if (s.right >= 0)                    
                    /* Add to the end of the StringBuilder error message
                       the column number of the error in the input. */
                    m.append(", column "+(s.right+1));
            }
        }
   
        /* Add to the end of the StringBuilder error message created in
           this method the message that was passed into this method. */
        m.append(" : "+message);
   
        /* Print the contents of the StringBuilder 'm', which contains
           an error message, out on a line. */
        System.err.println(m);
    }
   
    /* Change the method report_fatal_error so when it reports a fatal
       error it will display the line and column number of where the
       fatal error occurred in the input as well as the reason for the
       fatal error which is passed into the method in the object
       'message' and then exit.*/
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};
   

   
/* ------------Declaration of Terminals and Non Terminals Section----------- */
/* Types */
terminal            INTEGER, CHAR, BOOLEAN, STRING, VAR, ARRAY;

/*Booleans */
terminal            TRUE, FALSE;

/*ciclos */
terminal            PROCEDURE, IF, ELSE, WHILE, DO, FOR, TO, REPEAT, THEN, BEGIN, END, OF, IN;

/*functions */
terminal            PROGRAM;

/*Symbols*/
terminal            SEMICOLON, COLON, COMMA, DOT;   

/*IO*/
terminal            READ, WRITE;

/* Arithmetic */
terminal            PLUS,MINUS,TIMES,DIVIDE;

/*Groups*/
terminal            LPAREN, RPAREN, LCOR, RCOR;

/* Boolean Expressions */
terminal            GREATEREQ, LESSEQ, GREATER, LESS, NEQ, EQU;

/* Logic operators */
terminal            NOT, OR, AND;

/*Assignment*/
terminal            ASSIGN;

/*Values*/
terminal    String      ID;
terminal    String      CONSTSTR;
terminal    Integer     NUMBER;
terminal    Character   CONSTCHAR;


/* Non terminals used in the grammar section. */
non terminal signo;
non terminal declaracion_variable;
non terminal operador_suma; 
non terminal operador_multiplicacion;
non terminal operador_relacional;
non terminal grupo_parametros;
non terminal parte_declaracion_variable;
non terminal parte_declaracion_funciones;
non terminal declaracion_var;
non terminal declaracion_funcion;
non terminal encabezamiento_funcion;
non terminal tipo_primitivo;

non terminal  tipo;

non terminal cadena;
non terminal bloque;
non terminal bloque_f;
non terminal integer_sin_signo;
non terminal variable; 
non terminal operador_condicional;
non terminal expresion;
non terminal expresion_simple;
non terminal termino;
non terminal factor;
non terminal sentencia;
non terminal sentencia_simple;
non terminal asignacion_sentencia;
non terminal sentencia_compuesta;
non terminal seccion_sentencia;
non terminal programa;
non terminal llamada_funcion;
non terminal parametro_actual;
non terminal sentencia_estructurada;
non terminal if_sentencia;
non terminal while_sentencia;
non terminal for_sentencia;
non terminal parte_else;
non terminal valor_inicial;
non terminal valor_final;
non terminal lectura_sentencia;
non terminal lectura;
non terminal escritura_sentencia;
non terminal escritura;
non terminal retorno;
non terminal expresiones_if;
non terminal expresion_if;

nonterminal String parametros;

/*-----------------------------------------------------------------*/
/* ----------------------------Grammar Section-------------------- */
/*-----------------------------------------------------------------*/






/*------------bloques de decision--------------------------*/

expresion_if ::= expresion:exp 
;
expresiones_if ::= expresion_if:ex_if operador_condicional expresiones_if
                |expresion_if:ex_if 
;

if_sentencia ::= IF LPAREN expresiones_if:exp_if RPAREN seccion_sentencia:s SEMICOLON 
	        |IF LPAREN expresiones_if:exp RPAREN seccion_sentencia:s parte_else:p_e SEMICOLON
;

parte_else ::= ELSE seccion_sentencia:s 
;



while_sentencia ::= WHILE expresion:exp DO seccion_sentencia:s  SEMICOLON
;

for_sentencia ::= FOR ID:id IN valor_inicial:v_i TO valor_final:v_f DO seccion_sentencia:s SEMICOLON
;


valor_inicial ::= expresion:exp 
;

valor_final ::= expresion:exp 
;


/*-------------enteros---------------------*/
signo ::= PLUS | MINUS
;
integer_sin_signo::= NUMBER
;

/*-------------variables------------------*/
declaracion_variable ::= ID:id COMMA declaracion_variable

			 |ID:id COLON tipo:t
|ID  COLON error
 ;

variable ::= ID: id 
;


/*-------------expresiones------------------*/


cadena::=CONSTSTR
        |CONSTCHAR
;
/*-------------operadores-------------------------*/
operador_suma::=PLUS|MINUS
;
operador_multiplicacion::=TIMES|DIVIDE
;
operador_relacional::=EQU|NEQ|GREATER|LESS|GREATEREQ|LESSEQ
;
operador_condicional ::= AND|OR
;


/*-------------llamada a funcion------------------*/
llamada_funcion::=ID:id LPAREN RPAREN
		  |ID:id LPAREN parametros:param RPAREN
                  |ID:id LPAREN parametros:param error SEMICOLON 
;

parametros::=parametro_actual:p_a COMMA parametros:p
	     | parametro_actual:p_a 
;

/*-------------sentencias--------------------------*/
sentencia::= sentencia_simple:s_s
	     |sentencia_estructurada:s_e 
;

sentencia_simple ::= asignacion_sentencia:a_s
		     | llamada_funcion:l_f SEMICOLON
		     | lectura_sentencia:l_s
		     | escritura_sentencia:e_s
                     ;

/*-------------sentencia asignacion--------------------------*/
asignacion_sentencia ::= variable:var ASSIGN expresion:exp SEMICOLON

                        |variable:var ASSIGN error SEMICOLON

                        |variable:var EQU error expresion:exp SEMICOLON

                        |variable:var COLON error expresion:exp SEMICOLON
;

/*-------------sentencia estructurada--------------------------*/
sentencia_estructurada::=sentencia_compuesta:s_c
			| if_sentencia:i_s
			| while_sentencia:w_s
			| for_sentencia:f_s
  ;                      


sentencia_compuesta::= BEGIN seccion_sentencia:s_s END
                       |BEGIN END
                       |BEGIN seccion_sentencia:s_s error 
;

seccion_sentencia::= sentencia:s  seccion_sentencia
		     |sentencia:s 
;

/


/*------------declaracion procedimientos--------------------------*/

grupo_parametros::=tipo:t ID:id COMMA grupo_parametros
                   |tipo:t ID:id 
;

parametro_actual::=expresion:exp 
;








/*--------------lectura y escritura---------------------------------------------------------------*/

lectura_sentencia ::= READ LPAREN lectura:lect RPAREN SEMICOLON

                      |READ LPAREN  error RPAREN SEMICOLON
                      |READ LPAREN  error

                      ;

lectura::= variable:var

                    ;

escritura_sentencia::= WRITE LPAREN escritura:esc RPAREN SEMICOLON
                      |WRITE LPAREN error RPAREN SEMICOLON

                      ;

escritura ::= cadena:cad COMMA variable:var

	      |cadena:cad
              ;